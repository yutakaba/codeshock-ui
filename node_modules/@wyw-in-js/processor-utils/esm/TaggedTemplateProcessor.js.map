{"version":3,"file":"TaggedTemplateProcessor.js","names":["ValueType","BaseProcessor","templateProcessor","validateParams","TaggedTemplateProcessor","template","constructor","params","args","SKIP","tag","forEach","element","kind","FUNCTION","dependencies","push","build","values","artifacts","length","Error","artifact","options","variableNameConfig","toString"],"sources":["../src/TaggedTemplateProcessor.ts"],"sourcesContent":["import type { TemplateElement, Expression, SourceLocation } from '@babel/types';\n\nimport type { ExpressionValue } from '@wyw-in-js/shared';\nimport { ValueType } from '@wyw-in-js/shared';\n\nimport type { TailProcessorParams } from './BaseProcessor';\nimport { BaseProcessor } from './BaseProcessor';\nimport type { ValueCache, Rules, Params } from './types';\nimport templateProcessor from './utils/templateProcessor';\nimport { validateParams } from './utils/validateParams';\n\nexport abstract class TaggedTemplateProcessor extends BaseProcessor {\n  readonly #template: (TemplateElement | ExpressionValue)[];\n\n  protected constructor(params: Params, ...args: TailProcessorParams) {\n    // Should have at least two params and the first one should be a callee.\n    validateParams(params, ['callee', '...'], TaggedTemplateProcessor.SKIP);\n\n    validateParams(\n      params,\n      ['callee', 'template'],\n      'Invalid usage of template tag'\n    );\n    const [tag, [, template]] = params;\n\n    super([tag], ...args);\n\n    template.forEach((element) => {\n      if ('kind' in element && element.kind !== ValueType.FUNCTION) {\n        this.dependencies.push(element);\n      }\n    });\n\n    this.#template = template;\n  }\n\n  public override build(values: ValueCache) {\n    if (this.artifacts.length > 0) {\n      // FIXME: why it was called twice?\n      throw new Error('Tag is already built');\n    }\n\n    const artifact = templateProcessor(\n      this,\n      this.#template,\n      values,\n      this.options.variableNameConfig\n    );\n    if (artifact) {\n      this.artifacts.push(['css', artifact]);\n    }\n  }\n\n  public override toString(): string {\n    return `${super.toString()}\\`â€¦\\``;\n  }\n\n  /**\n   * It is called for each resolved expression in a template literal.\n   * @param node\n   * @param precedingCss\n   * @param source\n   * @param unit\n   * @return chunk of CSS that should be added to extracted CSS\n   */\n  public abstract addInterpolation(\n    node: Expression,\n    precedingCss: string,\n    source: string,\n    unit?: string\n  ): string;\n\n  public abstract extractRules(\n    valueCache: ValueCache,\n    cssText: string,\n    loc?: SourceLocation | null\n  ): Rules;\n}\n"],"mappings":"AAGA,SAASA,SAAS,QAAQ,mBAAmB;AAG7C,SAASC,aAAa,QAAQ,iBAAiB;AAE/C,OAAOC,iBAAiB,MAAM,2BAA2B;AACzD,SAASC,cAAc,QAAQ,wBAAwB;AAEvD,OAAO,MAAeC,uBAAuB,SAASH,aAAa,CAAC;EACzD,CAACI,QAAQ;EAERC,WAAWA,CAACC,MAAc,EAAE,GAAGC,IAAyB,EAAE;IAClE;IACAL,cAAc,CAACI,MAAM,EAAE,CAAC,QAAQ,EAAE,KAAK,CAAC,EAAEH,uBAAuB,CAACK,IAAI,CAAC;IAEvEN,cAAc,CACZI,MAAM,EACN,CAAC,QAAQ,EAAE,UAAU,CAAC,EACtB,+BACF,CAAC;IACD,MAAM,CAACG,GAAG,EAAE,GAAGL,QAAQ,CAAC,CAAC,GAAGE,MAAM;IAElC,KAAK,CAAC,CAACG,GAAG,CAAC,EAAE,GAAGF,IAAI,CAAC;IAErBH,QAAQ,CAACM,OAAO,CAAEC,OAAO,IAAK;MAC5B,IAAI,MAAM,IAAIA,OAAO,IAAIA,OAAO,CAACC,IAAI,KAAKb,SAAS,CAACc,QAAQ,EAAE;QAC5D,IAAI,CAACC,YAAY,CAACC,IAAI,CAACJ,OAAO,CAAC;MACjC;IACF,CAAC,CAAC;IAEF,IAAI,CAAC,CAACP,QAAQ,GAAGA,QAAQ;EAC3B;EAEgBY,KAAKA,CAACC,MAAkB,EAAE;IACxC,IAAI,IAAI,CAACC,SAAS,CAACC,MAAM,GAAG,CAAC,EAAE;MAC7B;MACA,MAAM,IAAIC,KAAK,CAAC,sBAAsB,CAAC;IACzC;IAEA,MAAMC,QAAQ,GAAGpB,iBAAiB,CAChC,IAAI,EACJ,IAAI,CAAC,CAACG,QAAQ,EACda,MAAM,EACN,IAAI,CAACK,OAAO,CAACC,kBACf,CAAC;IACD,IAAIF,QAAQ,EAAE;MACZ,IAAI,CAACH,SAAS,CAACH,IAAI,CAAC,CAAC,KAAK,EAAEM,QAAQ,CAAC,CAAC;IACxC;EACF;EAEgBG,QAAQA,CAAA,EAAW;IACjC,OAAQ,GAAE,KAAK,CAACA,QAAQ,CAAC,CAAE,OAAM;EACnC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AAaA"}