{"version":3,"file":"findPackageJSON.js","names":["_path","require","_findUp","_interopRequireDefault","obj","__esModule","default","cache","Map","findPackageJSON","pkgName","filename","_globalThis$process","isJest","Boolean","globalThis","process","env","JEST_WORKER_ID","skipPathsOptions","startsWith","pkgPath","isAbsolute","resolve","paths","dirname","has","set","findUp","sync","cwd","get","er","code","undefined"],"sources":["../src/findPackageJSON.ts"],"sourcesContent":["import { dirname, isAbsolute } from 'path';\nimport findUp from 'find-up';\n\nconst cache = new Map<string, string | undefined>();\n\nexport function findPackageJSON(\n  pkgName: string,\n  filename: string | null | undefined\n) {\n  // Jest's resolver does not work properly with `moduleNameMapper` when `paths` are defined\n  const isJest = Boolean(globalThis.process?.env?.JEST_WORKER_ID);\n  const skipPathsOptions = isJest && !pkgName.startsWith('.');\n\n  try {\n    const pkgPath =\n      pkgName === '.' && filename && isAbsolute(filename)\n        ? filename\n        : require.resolve(\n            pkgName,\n            filename ? { paths: [dirname(filename)] } : {}\n          );\n    if (!cache.has(pkgPath)) {\n      cache.set(pkgPath, findUp.sync('package.json', { cwd: pkgPath }));\n    }\n\n    return cache.get(pkgPath);\n  } catch (er: unknown) {\n    const code =\n      typeof er === 'object' && er !== null && 'code' in er\n        ? er.code\n        : undefined;\n\n    if (code === 'MODULE_NOT_FOUND') {\n      if (skipPathsOptions && filename) {\n        return findPackageJSON(pkgName, null);\n      }\n\n      return undefined;\n    }\n\n    if (code === 'ERR_PACKAGE_PATH_NOT_EXPORTED') {\n      // See https://github.com/Anber/wyw-in-js/issues/43\n      // `require` can't resolve ESM-only packages. We can use the `resolve`\n      // package here, but it does not solve all cases because `pkgName`\n      // can be an alias and should be resolved by a bundler. However, we can't use\n      // `resolve` from a bundler because it is async. The good news is that in that\n      // specific case, we can just ignore those packages. For now.\n      return undefined;\n    }\n\n    throw er;\n  }\n}\n"],"mappings":";;;;;;AAAA,IAAAA,KAAA,GAAAC,OAAA;AACA,IAAAC,OAAA,GAAAC,sBAAA,CAAAF,OAAA;AAA6B,SAAAE,uBAAAC,GAAA,WAAAA,GAAA,IAAAA,GAAA,CAAAC,UAAA,GAAAD,GAAA,KAAAE,OAAA,EAAAF,GAAA;AAE7B,MAAMG,KAAK,GAAG,IAAIC,GAAG,CAA6B,CAAC;AAE5C,SAASC,eAAeA,CAC7BC,OAAe,EACfC,QAAmC,EACnC;EAAA,IAAAC,mBAAA;EACA;EACA,MAAMC,MAAM,GAAGC,OAAO,EAAAF,mBAAA,GAACG,UAAU,CAACC,OAAO,cAAAJ,mBAAA,gBAAAA,mBAAA,GAAlBA,mBAAA,CAAoBK,GAAG,cAAAL,mBAAA,uBAAvBA,mBAAA,CAAyBM,cAAc,CAAC;EAC/D,MAAMC,gBAAgB,GAAGN,MAAM,IAAI,CAACH,OAAO,CAACU,UAAU,CAAC,GAAG,CAAC;EAE3D,IAAI;IACF,MAAMC,OAAO,GACXX,OAAO,KAAK,GAAG,IAAIC,QAAQ,IAAI,IAAAW,gBAAU,EAACX,QAAQ,CAAC,GAC/CA,QAAQ,GACRV,OAAO,CAACsB,OAAO,CACbb,OAAO,EACPC,QAAQ,GAAG;MAAEa,KAAK,EAAE,CAAC,IAAAC,aAAO,EAACd,QAAQ,CAAC;IAAE,CAAC,GAAG,CAAC,CAC/C,CAAC;IACP,IAAI,CAACJ,KAAK,CAACmB,GAAG,CAACL,OAAO,CAAC,EAAE;MACvBd,KAAK,CAACoB,GAAG,CAACN,OAAO,EAAEO,eAAM,CAACC,IAAI,CAAC,cAAc,EAAE;QAAEC,GAAG,EAAET;MAAQ,CAAC,CAAC,CAAC;IACnE;IAEA,OAAOd,KAAK,CAACwB,GAAG,CAACV,OAAO,CAAC;EAC3B,CAAC,CAAC,OAAOW,EAAW,EAAE;IACpB,MAAMC,IAAI,GACR,OAAOD,EAAE,KAAK,QAAQ,IAAIA,EAAE,KAAK,IAAI,IAAI,MAAM,IAAIA,EAAE,GACjDA,EAAE,CAACC,IAAI,GACPC,SAAS;IAEf,IAAID,IAAI,KAAK,kBAAkB,EAAE;MAC/B,IAAId,gBAAgB,IAAIR,QAAQ,EAAE;QAChC,OAAOF,eAAe,CAACC,OAAO,EAAE,IAAI,CAAC;MACvC;MAEA,OAAOwB,SAAS;IAClB;IAEA,IAAID,IAAI,KAAK,+BAA+B,EAAE;MAC5C;MACA;MACA;MACA;MACA;MACA;MACA,OAAOC,SAAS;IAClB;IAEA,MAAMF,EAAE;EACV;AACF"}