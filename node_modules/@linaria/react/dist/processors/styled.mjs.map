{"version":3,"sources":["../../src/processors/styled.ts"],"sourcesContent":["import { readFileSync } from 'fs';\nimport { dirname, join, posix } from 'path';\n\nimport type {\n  CallExpression,\n  Expression,\n  ObjectExpression,\n  SourceLocation,\n  StringLiteral,\n  Identifier,\n} from '@babel/types';\nimport {\n  buildSlug,\n  TaggedTemplateProcessor,\n  validateParams,\n  toValidCSSIdentifier,\n} from '@wyw-in-js/processor-utils';\nimport type {\n  Params,\n  Rules,\n  TailProcessorParams,\n  ValueCache,\n} from '@wyw-in-js/processor-utils';\nimport type { IVariableContext } from '@wyw-in-js/shared';\nimport {\n  findPackageJSON,\n  hasEvalMeta,\n  slugify,\n  ValueType,\n} from '@wyw-in-js/shared';\nimport { minimatch } from 'minimatch';\nimport html from 'react-html-attributes';\nimport { sync as resolveSync } from 'resolve';\n\nconst isNotNull = <T>(x: T | null): x is T => x !== null;\n\nconst allTagsSet = new Set([...html.elements.html, html.elements.svg]);\n\nexport type WrappedNode =\n  | string\n  | { node: Identifier; nonLinaria?: true; source: string };\n\nexport interface IProps {\n  atomic?: boolean;\n  class?: string;\n  name: string;\n  propsAsIs: boolean;\n  vars?: Record<string, Expression[]>;\n}\n\nconst singleQuotedStringLiteral = (value: string): StringLiteral => ({\n  type: 'StringLiteral',\n  value,\n  extra: {\n    rawValue: value,\n    raw: `'${value}'`,\n  },\n});\n\nexport default class StyledProcessor extends TaggedTemplateProcessor {\n  public component: WrappedNode;\n\n  #variableIdx = 0;\n\n  #variablesCache = new Map<string, string>();\n\n  constructor(params: Params, ...args: TailProcessorParams) {\n    // Should have at least two params and the first one should be a callee.\n    validateParams(\n      params,\n      ['callee', '*', '...'],\n      TaggedTemplateProcessor.SKIP\n    );\n\n    validateParams(\n      params,\n      ['callee', ['call', 'member'], ['template', 'call']],\n      'Invalid usage of `styled` tag'\n    );\n\n    const [tag, tagOp, template] = params;\n\n    if (template[0] === 'call') {\n      // It is already transformed styled-literal. Skip it.\n      // eslint-disable-next-line @typescript-eslint/no-throw-literal\n      throw TaggedTemplateProcessor.SKIP;\n    }\n\n    super([tag, template], ...args);\n\n    let component: WrappedNode | undefined;\n    if (tagOp[0] === 'call' && tagOp.length === 2) {\n      const value = tagOp[1];\n      if (value.kind === ValueType.FUNCTION) {\n        component = 'FunctionalComponent';\n      } else if (value.kind === ValueType.CONST) {\n        component = typeof value.value === 'string' ? value.value : undefined;\n      } else {\n        if (value.importedFrom?.length) {\n          const selfPkg = findPackageJSON('.', this.context.filename);\n\n          // Check if at least one used identifier is a Linaria component.\n          const isSomeMatched = value.importedFrom.some((importedFrom) => {\n            const importedPkg =\n              // If package.json is not found, assume it's a local package\n              findPackageJSON(importedFrom, this.context.filename) ?? selfPkg;\n\n            if (importedPkg) {\n              const packageJSON = JSON.parse(readFileSync(importedPkg, 'utf8'));\n              const mask: string | undefined = packageJSON?.linaria?.components;\n              if (importedPkg === selfPkg && mask === undefined) {\n                // If mask is not specified for the local package, all components are treated as styled.\n                return true;\n              }\n\n              if (mask) {\n                const packageDir = dirname(importedPkg);\n                // Masks for minimatch should always use POSIX slashes\n                const fullMask = join(packageDir, mask).replace(\n                  /\\\\/g,\n                  posix.sep\n                );\n\n                try {\n                  const fileWithComponent = resolveSync(importedFrom, {\n                    basedir: dirname(this.context.filename!),\n                    extensions: this.options.extensions,\n                  });\n\n                  return minimatch(fileWithComponent, fullMask);\n                } catch (e) {\n                  // It means that resolver can't find the file.\n                  // eslint-disable-next-line no-console\n                  console.warn(\n                    `Can't resolve ${importedFrom} from ${this.context.filename}. If ${value.source} is another styled component, it should be resolvable with default Node.js resolver. If it's not, please exclude it from the linaria.components mask in package.json.`\n                  );\n\n                  return false;\n                }\n              }\n            }\n\n            return false;\n          });\n\n          if (!isSomeMatched) {\n            component = {\n              node: value.ex,\n              nonLinaria: true,\n              source: value.source,\n            };\n          }\n        }\n\n        if (component === undefined) {\n          component = {\n            node: value.ex,\n            source: value.source,\n          };\n\n          this.dependencies.push(value);\n        }\n      }\n    }\n\n    if (tagOp[0] === 'member') {\n      [, component] = tagOp;\n    }\n\n    if (!component) {\n      throw new Error('Invalid usage of `styled` tag');\n    }\n\n    this.component = component;\n  }\n\n  public override get asSelector(): string {\n    return `.${this.className}`;\n  }\n\n  public override get value(): ObjectExpression {\n    const t = this.astService;\n    const extendsNode =\n      typeof this.component === 'string' || this.component.nonLinaria\n        ? null\n        : this.component.node.name;\n\n    return t.objectExpression([\n      t.objectProperty(\n        t.stringLiteral('displayName'),\n        t.stringLiteral(this.displayName)\n      ),\n      t.objectProperty(\n        t.stringLiteral('__wyw_meta'),\n        t.objectExpression([\n          t.objectProperty(\n            t.stringLiteral('className'),\n            t.stringLiteral(this.className)\n          ),\n          t.objectProperty(\n            t.stringLiteral('extends'),\n            extendsNode\n              ? t.callExpression(t.identifier(extendsNode), [])\n              : t.nullLiteral()\n          ),\n        ])\n      ),\n    ]);\n  }\n\n  protected get tagExpression(): CallExpression {\n    const t = this.astService;\n    return t.callExpression(this.callee, [this.tagExpressionArgument]);\n  }\n\n  protected get tagExpressionArgument(): Expression {\n    const t = this.astService;\n    if (typeof this.component === 'string') {\n      if (this.component === 'FunctionalComponent') {\n        return t.arrowFunctionExpression([], t.blockStatement([]));\n      }\n\n      return singleQuotedStringLiteral(this.component);\n    }\n\n    return t.callExpression(t.identifier(this.component.node.name), []);\n  }\n\n  public override addInterpolation(\n    node: Expression,\n    precedingCss: string,\n    source: string,\n    unit = ''\n  ): string {\n    const id = this.getVariableId(source, unit, precedingCss);\n\n    this.interpolations.push({\n      id,\n      node,\n      source,\n      unit,\n    });\n\n    return id;\n  }\n\n  public override doEvaltimeReplacement(): void {\n    this.replacer(this.value, false);\n  }\n\n  public override doRuntimeReplacement(): void {\n    const t = this.astService;\n\n    const props = this.getProps();\n\n    this.replacer(\n      t.callExpression(this.tagExpression, [this.getTagComponentProps(props)]),\n      true\n    );\n  }\n\n  public override extractRules(\n    valueCache: ValueCache,\n    cssText: string,\n    loc?: SourceLocation | null\n  ): Rules {\n    const rules: Rules = {};\n\n    let selector = `.${this.className}`;\n\n    // If `styled` wraps another component and not a primitive,\n    // get its class name to create a more specific selector\n    // it'll ensure that styles are overridden properly\n    let value =\n      typeof this.component === 'string' || this.component.nonLinaria\n        ? null\n        : valueCache.get(this.component.node.name);\n    while (hasEvalMeta(value)) {\n      selector += `.${value.__wyw_meta.className}`;\n      value = value.__wyw_meta.extends;\n    }\n\n    rules[selector] = {\n      cssText,\n      className: this.className,\n      displayName: this.displayName,\n      start: loc?.start ?? null,\n    };\n\n    return rules;\n  }\n\n  public override toString(): string {\n    const res = (arg: string) => `${this.tagSourceCode()}(${arg})\\`…\\``;\n\n    if (typeof this.component === 'string') {\n      if (this.component === 'FunctionalComponent') {\n        return res('() => {…}');\n      }\n\n      return res(`'${this.component}'`);\n    }\n\n    return res(this.component.source);\n  }\n\n  protected getCustomVariableId(\n    source: string,\n    unit: string,\n    precedingCss: string\n  ) {\n    const context = this.getVariableContext(source, unit, precedingCss);\n    const customSlugFn = this.options.variableNameSlug;\n    if (!customSlugFn) {\n      return undefined;\n    }\n\n    return typeof customSlugFn === 'function'\n      ? customSlugFn(context)\n      : buildSlug(customSlugFn, { ...context });\n  }\n\n  protected getProps(): IProps {\n    const propsObj: IProps = {\n      name: this.displayName,\n      class: this.className,\n      propsAsIs:\n        typeof this.component !== 'string' || !allTagsSet.has(this.component),\n    };\n\n    // If we found any interpolations, also pass them, so they can be applied\n    if (this.interpolations.length) {\n      propsObj.vars = {};\n      this.interpolations.forEach(({ id, unit, node }) => {\n        const items: Expression[] = [this.astService.callExpression(node, [])];\n\n        if (unit) {\n          items.push(this.astService.stringLiteral(unit));\n        }\n\n        propsObj.vars![id] = items;\n      });\n    }\n\n    return propsObj;\n  }\n\n  protected getTagComponentProps(props: IProps): ObjectExpression {\n    const t = this.astService;\n\n    const propExpressions = Object.entries(props)\n      .map(([key, value]: [key: string, value: IProps[keyof IProps]]) => {\n        if (value === undefined) {\n          return null;\n        }\n\n        const keyNode = t.identifier(key);\n\n        if (value === null) {\n          return t.objectProperty(keyNode, t.nullLiteral());\n        }\n\n        if (typeof value === 'string') {\n          return t.objectProperty(keyNode, t.stringLiteral(value));\n        }\n\n        if (typeof value === 'boolean') {\n          return t.objectProperty(keyNode, t.booleanLiteral(value));\n        }\n\n        const vars = Object.entries(value).map(([propName, propValue]) => {\n          return t.objectProperty(\n            t.stringLiteral(propName),\n            t.arrayExpression(propValue)\n          );\n        });\n\n        return t.objectProperty(keyNode, t.objectExpression(vars));\n      })\n      .filter(isNotNull);\n\n    return t.objectExpression(propExpressions);\n  }\n\n  protected getVariableContext(\n    source: string,\n    unit: string,\n    precedingCss: string\n  ): IVariableContext {\n    const getIndex = () => {\n      // eslint-disable-next-line no-plusplus\n      return this.#variableIdx++;\n    };\n\n    return {\n      componentName: this.displayName,\n      componentSlug: this.slug,\n      get index() {\n        return getIndex();\n      },\n      precedingCss,\n      processor: this.constructor.name,\n      source,\n      unit,\n      valueSlug: slugify(source + unit),\n    };\n  }\n\n  protected getVariableId(\n    source: string,\n    unit: string,\n    precedingCss: string\n  ): string {\n    const value = source + unit;\n    if (!this.#variablesCache.has(value)) {\n      const id = this.getCustomVariableId(source, unit, precedingCss);\n      if (id) {\n        return toValidCSSIdentifier(id);\n      }\n\n      const context = this.getVariableContext(source, unit, precedingCss);\n\n      // make the variable unique to this styled component\n      this.#variablesCache.set(value, `${this.slug}-${context.index}`);\n    }\n\n    return this.#variablesCache.get(value)!;\n  }\n}\n"],"mappings":"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","names":[]}